## 架构到底是指什么
架构：软件架构指软件系统的顶层结构  
框架：面向编程或配置的半成品  
组件：从技术维度上的复用    
模块：是从业务维度上职责的划分  
系统：相互协同可运行的实体  

## 架构设计的目的
从需求出发，有什么样的需求，就用什么样的架构，不可上来就用特别复杂的架构，总体来说就是满足复杂度和变更，不存在银弹。
考虑下面几个问题：
1. 高可用和高性能:到底要多高，为什么要高性能高可用?
2. 低延迟:到底多低?秒级和分钟级和小时级，复杂度差很大，秒级你可能要用流式计算， 分钟级用后台计算可能就可以了，小时级直接用数据库就可以了
3. 系统高可用具体达到什么水平?是1分钟都不能停，还是可以停1个小时?是数据绝对不能 丢，还是可以丢一部分数据然后其它方式修复?
我觉得做软件架构是为两件事服务的:业务架构和业务量级，这应该算是“软件系统复杂度
带来问题”的具体化。
业务架构和业务量级都是从每个具体项目的实际应用场景中提炼出来的。
业务架构是对业务需求的提炼和抽象，开发软件必须要满足业务需求，否则就是空中楼阁。
软件系统业务上的复杂度问题，可以从业务架构的角度切分工作交界面来解决。设计软件架
构，首先是要保证能和业务架构对的上，这也是从业务逻辑转向代码逻辑的过程，所以软件
架构的设计为开发指明了方向。另外架构设计也为接下来的开发工作分工奠定了基础。
业务量级表现在存储能力、吞吐能力和容错能力等，主要是软件运维期业务的复杂度。做软
件架构设计，是要保证软件有能力托起它在业务量级上的要求的，如果软件到运行使用期废
了，前面所有的工作都付诸东流了。不同的业务量级，对应的软件的架构复杂度是不同的，
所以对于不同的项目，业务量级不同，架构设计也不同。  
做业务架构必须与其面向的实际应用场景相匹配，由于每个产品或项目的业务场景均有所不
同，所以每次做新的软件开发前，必须先设计软件架构，试图不经分析直接套用先前的架构
方案，十有八九会让当前的系统在某个点上报出大问题导致推翻重来，更不要说直接拿别人
的现成架构方案了。  
所以每个软件在开发前，都要结合自己的应用场景设计适合自身的软件架构，现成的架构方
案只能借鉴，不能直接套用。  
另外，由于业务架构和业务量级也会不断调整或长大，软件架构也不是一劳永逸的，会随业 务不断调整。

## 复杂度来源：高性能
1 WHAT 对高性能的理解? 性能是软件的一个重要质量属性。衡量软件性能包括了响应时间、TPS、服务器资源利用率等 客观指标，也可以是用户的主观感受(从程序员、业务用户、终端用户/客户不同的视角，可 能会得出不同的结论)。
在说性能的时候，有一个概念与之紧密相关—伸缩性，这是两个有区别的概念。性能更多的 是衡量软件系统处理一个请求或执行一个任务需要耗费的时间长短;而伸缩性则更加关注软 件系统在不影响用户体验的前提下，能够随着请求数量或执行任务数量的增加(减少)而相 应地拥有相适应的处理能力。
但是，什么是“高”性能?这可能是一个动态概念，与当前的技术发展状况与业务所处的阶 段紧密相关。比如，现在在行业/企业内部认为的高性能，站在5年后来看，未必是高性能。 因此，站在架构师、设计师的角度，高性能需要和业务所处的阶段来衡量。高到什么程度才 能与当前或可预见的未来业务增长相匹配。一味去追求绝对意义上的高，没有太大的实际意 义。因为，伴随性能越来越高，相应的方法和系统复杂度也是越来越高，而这可能会与当前 团队的人力、技术、资源等不相匹配。但是什么才合适的高性能了?这可能需要从国、内外 的同行业规模相当、比自己强的竞争者、终端用户使用反馈中获取答案并不断迭代发展。
软件系统中高性能带来的复杂度主要体现在两方面，一方面是单台计算机内部为了高性能带
来的复杂度;另一方面是多台计算机集群为了高性能带来的复杂度。
2 WHY 为什么需要高性能? 追求良好的用户体验; 满足业务增长的需要。
3 HOW 如何做好高性能? 可以从垂直与水平两个维度来考虑。垂直维度主要是针对单台计算机，通过升级软、硬件能 力实现性能提升;水平维度则主要针对集群系统，利用合理的任务分配与任务分解实现性能 的提升。
垂直维度可包括以下措施:
增大内存减少I/O操作 更换为固态硬盘(SSD)提升I/O访问速度 使用RAID增加I/O吞吐能力 置换服务器获得更多的处理器或分配更多的虚拟核 升级网络接口或增加网络接口
水平维度可包括以下措施:
功能分解:基于功能将系统分解为更小的子系统
多实例副本:同一组件重复部署到多台不同的服务器
数据分割:在每台机器上都只部署一部分数据
垂直维度方案比较适合业务阶段早期和成本可接受的阶段，该方案是提升性能最简单直接的
方式，但是受成本与硬件能力天花板的限制。
水平维度方案所带来的好处要在业务发展的后期才能体现出来。起初，该方案会花费更多的 硬件成本，另外一方面对技术团队也提出了更高的要求;但是，没有垂直方案的天花板问 题。一旦达到一定的业务阶段，水平维度是技术发展的必由之路。因此，作为技术部门，需 要提前布局 ，未雨绸缪，不要被业务抛的太远。

## 复杂度来源：高可用
定义：系统无中断地执行其功能的能力，代表系统的可用性程度，是进行系统设计时的准则之一。
需求驱动驱动;而高可用与高性能，是架构设计中两个非常重要的决策因素。因此，面对不 同业务系统的不同需求，对高可用与高性能也会有不同的决策结论，其实现的复杂度也各不 相同。支付宝业务，对于可用性和性能就会有很高的要求，在可用性方面希望能提供7*24不 间断服务，在高性能方面则希望能实时收付款;而对于一个学生管理系统，在可用性与性能 方面就不一定要有多高的要求，比如晚上可关机，几秒内能查询到信息也可接受。为此，高 可用性与高性能的复杂度讨论需要结合业务需求。
1 WHAT - 什么是可用性? 定义可用性，可以先定义什么是不可用。需要经历若干环节，网站的页面才能呈现在最终的 用户面前;而其中的任何一个环节出现了故障，都可能会导致网站的页面不可访问，也就是 出现了网站不可用的情况。昨夜iOS版本QQ出现大面积闪退就是一个系统不可用的典型案 例。
我们可以利用百分比来对网站可用性进行度量: 网站不可用时间=完成故障修复的时间点 - 故障发现的时间点
网站年度可用时间=年度总时间 - 网站不可用时间 网站年度可用性=(网站年度可用时间/年度总时间) x 100%
举例:一些知名大型网站的可用性可达到99.99%(俗称4个9)，我们可以算一下一年下来留 给处理故障的时间有多少?
年度总时间=365*24*60=525600分钟
网站不可用时间=525600*(1-99.99%)=52.56分钟 也就是，如果网站要达到4个9的可用性，一年下来网站不可用时间最多53分钟(也就是不足 1个小时)。
可见，高可用性就是技术实力的象征，高可用性就是竞争力。
2 WHY - 为什么会出现不可用? 硬件故障。网站多运行在普通的商用服务器，而这些服务器本身就不具备高可用性，再加之 网站系统背后有数量众多服务器，那么一定时间内服务器宕机是大概率事件，直接导致部署 在该服务器上的服务受影响。
软件BUG或网站更新升级发布。BUG不能消灭，只能减少;上线后的系统在运行过程中，难 免会出现故障，而这些故障同样直接导致某些网站服务不可用;此外，网站更新升级发布也 会引起相对较频繁的服务器宕机。
不可抗拒力。如地震、水灾、战争等。
3 HOW - 如何做到高可用 核心思想:网站高可用的主要技术手段是服务与数据的冗余备份与失效转移。同一服务组件 部署在多台服务器上;数据存储在多台服务器上互相备份。通过上述技术手段，当任何一台 服务器宕机或出现各种不可预期的问题时，就将相应的服务切换到其他可用的服务器上，不 影响系统的整体可用性，也不会导致数据丢失。
从架构角度看可用性:当前网站系统多采用经典的分层模型，从上到下为:应用层、服务层
与数据层。应用层主要实现业务逻辑处理;服务层提供可复用的服务;数据层负责数据读
写;在部署架构上常采用应用和数据分离部署，应用会部署到不同服务器上，这些服务器被
称为应用层的服务器;这些可复用的服务也会各自部署在不同服务器上，称为服务层的服务
器;而各类数据库系统、文件柜等数据则部署在数据层的服务器。
硬件故障方面引起不可用的技术解决措施:(1)应用服务器。可通过负载均衡设备将多个应用 服务器构建为集群对外提供服务(前提是这些服务需要设计为无状态，即应用服务器不保存 业务的上下文信息，而仅根据每次请求提交的数据进行业务逻辑的操作响应)，当均衡设备 通过心跳检测手段检测到应用服务器不可用时，则将其从集群中移除，并将请求切换到其他 可用的应用服务上。(2)服务层服务器。这些服务器被应用层通过分布式服务框架(如Dubb o)访问，分布式服务框架可在应用层客户端程序中实现软件负载均衡，并通过服务注册中心 提供服务的服务器进行心跳检测，当发现有服务器不可用时，立即通知客户端程序修改服务 列表，同时移除响应的服务器。(3)数据服务器。需要在数据写入时进行数据同步复制，将数
据写入多台服务器上，实现数据冗余备份;当数据服务器宕机时，应用程序将访问切换到有
备份数据的服务器上。
软件方面引起不可用的技术解决措施:通过软件开发过程进行质量保证。通过预发布验证、 严格测试、灰度发布等手段，尽量减少上线服务的故障。
高性能，不管通过什么方式，或多或少，性能总获提高，行为上非必须做;高可用必须做，
因为系统宕机或数据丢失时，谈高性能也无意义

## 复杂度来源：可拓展性
1 What:什么是架构的可扩展性?
业务需求、运行环境方面的变化都会导致软件系统发生变化，而这种软件系统对上述变化的
适应能力就是可扩展性。
可扩展性可以理解为是一种从功能需求方面考虑的软件属性，属性就会存在好坏之分。
按照可扩展性的定义，一个具备良好可扩展性的架构设计应当符合开闭原则:对扩展开放， 对修改关闭。衡量一个软件系统具备良好可扩展性主要表现但不限于:(1)软件自身内部方 面。在软件系统实现新增的业务功能时，对现有系统功能影响较少，即不需要对现有功能作 任何改动或者很少改动。(2)软件外部方面。软件系统本身与其他存在协同关系的外部系统 之间存在松耦合关系，软件系统的变化对其他软件系统无影响，其他软件系统和功能不需要 进行改动。反之，则是一个可扩展性不好的软件系统。
2 Why:为什么要求架构具备良好的可扩展性?
伴随业务的发展、创新，运行环境的变化，对技术也就提出了更多、更高的要求。能够快速
响应上述变化，并最大程度降低对现有系统的影响，是设计可扩展性好的架构的主要目的。
3 How:如何设计可扩展性好的架构?
面向对象思想、设计模式都是为了解决可扩展性的而出现的方法与技术。
设计具备良好可扩展性的系统，有两个思考角度:(1)从业务维度。对业务深入理解，对可 预计的业务变化进行预测。(2)从技术维度。利用扩展性好的技术，实现对变化的封装。
(1)在业务维度。对业务深入理解，对业务的发展方向进行预判，也就是不能完全不考虑可扩 展性;但是，变化无处不在，在业务看得远一点的同时，需要注意:警惕过度设计;不能每个 设计点都考虑可扩展性;所有的预测都存在不正确的可能性。
(2)在技术维度。预测变化是一回事，采取什么方案来应对变化，又是另外一个复杂的事情。 即使预测很准确，如果方案不合适，则系统扩展一样很麻烦。第一种应对变化的常见方案是 将“变化”封装在一个“变化层”，将不变的部分封装在一个独立的“稳定层”。第二种常 见的应对变化的方案是提炼出一个“抽象层”和一个“实现层”。
4.在实际工作场景中的解决方案 在实际软件系统架构设计中，常通过以下技术手段实现良好的可扩展性:(1)使用分布式服务 (框架)构建可复用的业务平台。(2)使用分布式消息队列降低业务模块间的耦合性。
(1)分布式服务框架 利用分布式服务框架(如Dubbo)可以将业务逻辑实现和可复用组件服务分离开，通过接口降 低子系统或模块间的耦合性。新增功能时，可以通过调用可复用的组件实现自身的业务逻 辑，而对现有系统没有任何影响。可复用组件升级变更的时候，可以提供多版本服务对应用 实现透明升级，对现有应用不会造成影响。
(2) 分布式消息队列 基于生产者-消费者编程模式，利用分布式消息队列(如RabbitMQ)将用户请求、业务请求作 为消息发布者将事件构造成消息发布到消息队列，消息的订阅者作为消费者从消息队列中获 取消息进行处理。通过这种方式将消息生产和消息处理分离开来，可以透明地增加新的消息 生产者任务或者新的消息消费者任务。
平时工作中更多提醒自己压抑一下想预测各种需求变化的欲望。因为之前总是过度设计。 压抑并不是说不去考虑各种变化，而恰恰需要把可能性大的变化点一一罗列出来，分维度打
分，维度包括 可能性大小?长期还是短期会变化?如果发生变化，目前的组织和系统要花多 大成本适应变化。这些变化正是李老师之前说过的各种复杂度上的变化，比如用户量激增带 来的性能要求。此外还包括一个业务功能逻辑上的变化。 在经过上面分析后往往会给出“上中下”策的设计方案，下策一般考虑的变化少，短视，但 迅速，修改小，立竿见影。上策一般看重远期，但成本高很高，也很可能预测不中。 最后还要分析，如果决定采用下中策，如果预测的变化发生了，系统修改为中上策的代价有 多大，有些代价几乎是无穷大的，比如必须中断服务进行升级。如果代价小，那可以放心采 用下策或中策。如果答案是否，可上策当前的代价又真的不可接受，那又要返回头重新分析。
实践发现这个方法挺好用，尤其当有人来咨询架构方案时，往往对给出的结果比较满意。
设计的时候考虑可扩展性，但如果评估后发现可扩展性设计的代价太大， 那就暂时不做，等到真的有需求时再重构。
过早考虑可扩展性，很多通用性和抽象都是推测的，等到真的要落地了，很可能发现事实并非如此，这就是预测是错误的。
实际情况，分层最有用，代码中用设计模式，如果后面接手的人不懂或者理解不到位，最后改的代码简直没法理解，还不如面向过程

## 复杂度来源
### 低成本
### 安全  
    防ddos攻击
### 规模
    低成本
    What:低成本是架构设计中需要考虑一个约束条件，但不会是首要目标。低成本本质上是与 高性能和高可用冲突的，当无法设计出满足成本要求的方案，就只能协调并调整成本目标。
    How:一般通过“创新”达到低成本的目标。(1)引入新技术。主要复杂度在于需要去熟悉 新技术，并且将新技术与已有技术结合;一般中小型公司基本采用该方式达到目标。(2)开 创一个全新技术领域。主要复杂度在于需要去创造全新的理念和技术，并且与旧技术相比， 需要有质的飞跃，复杂度更高;一般大公司拥有更多的资源、技术实力会采用该方式来达到 低成本的目标。
    安全
    What:安全是一个庞大而又复杂的技术领域，一旦出问题，对业务和企业形象影响非常大。 从技术的角度来讲，包括(1)功能安全-“防小偷”，减少系统潜在的缺陷，阻止黑客破坏 行为;(2)架构安全—“防强盗”，保护系统不受恶意访问和攻击，保护系统的重要数据不 被窃取。由于是蓄意破坏系统，因此对影响也大得多。架构设计时需要特别关注架构安全。
    How:(1)功能安全。是一个逐步完善的过程，而且往往都是在问题出现后才能有针对性的 提出解决方案，与编码实现有关。(2)架构安全。传统企业主要通过防火墙实现不同区域的 访问控制，功能强大、性能一般，但是成本更高。互联网企业更多地是依靠运营商或者云服 务商强大的带宽和流量清洗的能力，较少自己来设计和实现。
    规模
    What:规模带来复杂度的主要原因就是“量变引起质变”，当数量超过一定的阈值后，复杂 度会发生质的变化。随着业务的发展，规模带来的常见复杂度有(1)业务功能越来越多，调 用逻辑越来越复杂;(2)数据容量、类型、关联关系越来越多。
    How:规模问题需要与高性能、高可用、高扩展、高伸缩性统一考虑。常采用“分而治之， 各个击破”的方法策略。
    是否还有其他复杂度原因?- 可伸缩性
    当前大型互联网网站需要面对大量用户高并发访问、存储更多数据、处理更高频次的用户交互。网站系统一般通过多种分布式技术将多台服务器组成集群对外提供服务。伸缩性一般是
    系统可以根据需求和成本调整自身处理能力的一种能力。伸缩性常意味着系统可以通过低成
    本并能够快速改变自身的处理能力以满足更多用户访问、处理更多数据而不会对用户体验造
    成任何影响。
    伸缩性度量指标包括(1)处理更高并发;(2)处理更多数据;(3)处理更高频次的用户交 互。
    其复杂度体现在(1)伸——增强系统在上述三个方面的处理能力;(2)缩——缩减系统处 理能力;(3)上述伸缩过程还必须相对低成本和快速。
    
    如何画架构图：4+1模型画架构 

### 架构设计的原则
成为架构师是每个程序员的梦想，但并不意味着把编程做好就能够自然而然地成为一个架构师，优秀程序员和架构师之间还有一个明显的鸿沟需要跨越，这个鸿沟就是“不确定性”。
对于编程来说，本质上是不能存在不确定的，对于同样一段代码，不管是谁写的，不管什么时候 执行，执行的结果应该都是确定的(注意:“确定的”并不等于“正确的”，有 bug 也是确定 的)。而对于架构设计来说，本质上是不确定的，同样的一个系统，A 公司和 B 公司做出来的 架构可能差异很大，但最后都能正常运转;同样一个方案，A 设计师认为应该这样做，B 设计师 认为应该那样做，看起来好像都有道理......相比编程来说，架构设计并没有像编程语言那样的语 法来进行约束，更多的时候是面对多种可能性时进行选择。
从大公司的架构发展提炼出下面几个原则：
* 合适原则  
    合适优于业界领先。预估量，业务反推架构演进，上来就选看起来很牛逼的架构，很可能导致项目的得不偿失，成本和收益不成比例，进而导致失败。（如没有淘宝的体量，照搬淘宝的架构并不一定好） 
    真正优秀的架构都是在企业当前人力、条件、业务等各种约束下设计出来的，能够合理地 将资源整合在一起并发挥出最大功效，并且能够快速落地。这也是很多 BAT 出来的架构师到了 小公司或者创业团队反而做不出成绩的原因，因为没有了大公司的平台、资源、积累，只是生搬 硬套大公司的做法，失败的概率非常高
* 简单原则  
    简单优于复杂。
    团队的压力有时也会有意无意地促进我们走向复杂的方向，因为大部分人在评价一个方案水平高 低的时候，复杂性是其中一个重要的参考指标。例如设计一个主备方案，如果你用心跳来实现， 可能大家都认为这太简单了。但如果你引入 ZooKeeper 来做主备决策，可能很多人会认为这个 方案更加“高大上”一些，毕竟 ZooKeeper 使用的是 ZAB 协议，而 ZAB 协议本身就很复杂。 其实，真正理解 ZAB 协议的人很少(我也不懂)，但并不妨碍我们都知道 ZAB 协议很优秀。刚才我聊的这些原因，会在潜意识层面促使初出茅庐的架构师，不自觉地追求架构的复杂性。
    无论是结构的复杂性，还是逻辑的复杂性，都会存在各种问 题，所以架构设计时如果简单的方案和复杂的方案都可以满足需求，最好选择简单的方案。 `《UNIX 编程艺术》`总结的 `KISS(Keep It Simple, Stupid!)`原则一样适应于架构设计
* 演化原则  
    演化优于一步到位。
    如果没有把握“软件架构需要根据业务发展不断变化”这个本质，在做架构设计的时候就很容易陷入一个误区:试图一步到位设计一个软件架构，期望不管业务如何变化，架构都稳如磐石。为了实现这样的目标，要么照搬业界大公司公开发表的方案;要么投入庞大的资源和时间来做各种各样的预测、分析、设计。无论哪种做法，后果都很明显:投入巨大，落地遥遥无期。更让人沮丧的是，就算跌跌撞撞拼死拼活终于落地，却发现很多预测和分析都是不靠谱的。
    软件架构设计同样是类似的过程:
    首先，设计出来的架构要满足当时的业务需要。
    其次，架构要不断地在实际应用过程中迭代，保留优秀的设计，修复有缺陷的设计，改正错误的设计，去掉无用的设计，使得架构逐渐完善。
    第三，当业务发生变化时，架构要扩展、重构，甚至重写;代码也许会重写，但有价值的经验、教训、逻辑、设计等(类似生物体内的基因)却可以在新架构中延续。
    原则优先级  
    合适原则第一考虑，优先满足业务需求;
    简单原则第二考虑，挑选简单方案快速落地验证;
    演进原则第三考虑，适当预测业务发展，感觉预测不准就不预测，等真的出现问题的时候演进即可

## 如何识别架构设计中的复杂度
### 识别复杂度步骤  
(1)构建复杂度的来源清单——高性能、可用性、扩展性、安全、低成本、规模等。 (2)结合需求、技术、团队、资源等对上述复杂度逐一分析是否需要?是否关键?
“高性能”主要从软件系统未来的TPS、响应时间、服务器资源利用率等客观指标，也可以从 用户的主观感受方面去考虑。
“可用性”主要从服务不中断等质量属性，符合行业政策、国家法规等方面去考虑。
“扩展性”则主要从功能需求的未来变更幅度等方面去考虑。
(3)按照上述的分析结论，得到复杂度按照优先级的排序清单，越是排在前面的复杂度，就 越关键，就越优先解决。
需要特别注意的是:随着所处的业务阶段不同、外部的技术条件和环境的不同，得到的复杂 度问题的优先级排序就会有所不同。一切皆变化。
### 常见系统的性能量级  
常见的要熟记：例如nginx负载均衡性能是3万左右， mc的读取性能5万左右，kafka号称百万级，zookeeper写入读取2万以上，http请求访问大 概在2万左右。
具体的数值和机器配置以及测试案例有关，但大概的量级不会变化很大。
如果是业务系统，由于业务复杂度差异很大，有的每秒500请求可能就是高性能了，因此需要`针对业务进行性能测试，确立性能基线，方便后续架构设计做比较`。

## 设计备选方案和选择备选
### 常见误区
设计大而全（远超系统实际tps,qps）   
设计方案单一，无备选方案（2-4个即可，至少有个备选，防止目光短浅）  
一味追求新技术（采用稳定的技术，满足不了再采用新技术）
备选方案全部都过于详细（分散精力），评审时不能过于纠结细节，最终挑选一个细化即可
### 选择备选
前面提到了那么多指导思想，真正应该选择哪种方法来评估和选择备选方案呢?我的答案就 是“360 度环评”!具体的操作方式为:列出我们需要关注的质量属性点，然后分别从这些质量 属性的维度去评估每个方案，再综合挑选适合当时情况的最优方案。
常见的方案质量属性点有:性能、可用性、硬件成本、项目投入、复杂度、安全性、可扩展性 等。在评估这些质量属性时，需要遵循架构设计原则 1“合适原则”和原则 2“简单原则”，避 免贪大求全，基本上某个质量属性能够满足一定时期内业务发展就可以了

### 详细方案设计


## 参考
架构-从零开始学架构（李运华）