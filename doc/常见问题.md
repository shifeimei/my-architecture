# part1
1. http状态码/header/请求方法, 哪些请求方法是幂等的
get,post,head,put,delete,options 除了put外都是幂等

2. https加密原理
握手阶段用非对称加密。公钥传输安全性问题，引入可信第三方加密传输公钥（证书）。
实际传输时用对称密钥（客户端产生）。
双向对称加密：客户端给服务端上报可支持的对称加密算法，服务端选择好后，用客户端的公钥加密再给客户端。

3. python协程原理/缺点
4. python GIL, 为什么有GIL 还需要threading
5. python gevent协程调度原理/缺点
6. 设计一个文本编辑器实现插入/删除/查询
小文本。大文本。
小的按行处理，直接内存全部加载处理。
大的按块处理，加载和处理都是按块。

7. 头条文章向用户推送避免重复推送的问题
已推送且已读，则标记为已成功推送。

8. 工作中遇到的印象深刻的问题
9，两个单链表求和
leetcode

10，两种存储引擎
myisam,innodb

11，http的返回码
12，mysql 索引
13，链表操作(在线写代码)
14，http状态码
15，UDP / TCP 协议

16，链表操作 [手写代码]
17，乐观锁 / 悲观锁
18，三次握手
19，Socket
socket是将传输层的协议（tcp/udp+端口）+网络层的ip组合的三元组。
基本操作：createsocket,bind,listen,connect

20，Hbase 底层原理
21，Map 底层原理
22，数据库分表 / 分库 / 集群
22.给定一个二叉树，返回二叉树每层的最左的值。
23.手里有一副扑克牌。按照下列规则吧他堆放桌上。一，拿出最上面的一张牌，放桌上，然后把接下来的一张牌放在扑克牌的最下面。循环，直到没有手牌。现在已知桌上牌的顺序。求原手牌的顺序。
24.redis内存不足，如何解决
25. mysql索引的使用和原理
26. epoll和poll,select的区别
27.实现一个有顺序的LinkedList，实现deleteAll(int val)方法删除所有值为val的节点，和save(int val)方法添加一个值为val的节点。
28.线程池的工作流程。线程的几种状态，什么情况会进入阻塞
java new,dead,runnable,running,blocked,waiting,time_waiting
操作系统的是，runnable,wait,running, new, dead
java的状态和os的状态要区分对待，出发点不一样。os从cpu状态来出发的，java从线程状态来看
java block(发生在synchronized), waiting发生在object.wait,thread.join(其实也是wait),locksupport.park
如果带了超时时间就是time_waiting,否则是wait
notifyall是唤醒所有线程竞争，只是有先后，但都会唤醒。
一般来说，条件不一定会真的满足，因此wait都和while一起使用
同时，wait要求必须先获得了监视器再释放，所以一般和synchronize一起使用
线程网络io,磁盘io时，java线程处于runnable状态

29.JDK基础 集合 锁 

30.Mysql的索引结构 聚簇索引
https://www.jianshu.com/p/9800b188d021
https://www.jianshu.com/p/fa8192853184
聚簇索引的优势
看上去聚簇索引的效率明显要低于非聚簇索引，因为每次使用辅助索引检索都要经过两次B+树查找，这不是多此一举吗？聚簇索引的优势在哪？
由于行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中，再次访问的时候，会在内存中完成访问，不必访问磁盘。这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。
辅助索引使用主键作为"指针"而不是使用地址值作为指针的好处是，减少了当出现行移动或者数据页分裂时辅助索引的维护工作，使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是InnoDB在移动行时无须更新辅助索引中的这个"指针"。也就是说行的位置（实现中通过16K的Page来定位）会随着数据库里数据的修改而发生变化（前面的B+树节点分裂以及Page的分裂），使用聚簇索引就可以保证不管这个主键B+树的节点如何变化，辅助索引树都不受影响。
聚簇索引适合用在排序的场合，非聚簇索引不适合
取出一定范围数据的时候，使用用聚簇索引
二级索引需要两次索引查找，而不是一次才能取到数据，因为存储引擎第一次需要通过二级索引找到索引的叶子节点，从而找到数据的主键，然后在聚簇索引中用主键再次查找索引，再找到数据
可以把相关数据保存在一起。例如实现电子邮箱时，可以根据用户 ID 来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘 I/O。
劣势：
维护索引很昂贵，特别是插入新行或者主键被更新导至要分页(page split)的时候。建议在大量插入新行后，选在负载较低的时间段，通过OPTIMIZE TABLE优化表，因为必须被移动的行数据可能造成碎片。使用独享表空间可以弱化碎片
表因为使用UUId（随机ID）作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫面更慢
如果主键比较大的话，那辅助索引将会变的更大，因为辅助索引的叶子存储的是主键值；过长的主键值，会导致非叶子节点占用占用更多的物理空间

31限流。限流算法。令牌桶的不足
https://www.cnblogs.com/xuwc/p/9123078.html
简单计数器，滑动窗口计数器，漏桶，令牌桶
(a) 简单计数器是最容易想到的，分成很多时间段，该时间段内不能超过多少次。
滑动窗口计数器则是，窗口和窗口之间最小间隔是t,t很小，窗口之间都是重叠的
(b) ratelimit是令牌桶的一种实现
ratelimit原理：（每次请求都会resync）
    if (nowMicros > nextFreeTicketMicros) {
      storedPermits = min(maxPermits,
          storedPermits
            + (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros());
      nextFreeTicketMicros = nowMicros;
比较：
令牌桶是按照固定速率往桶中添加令牌，请求是否被处理需要看桶中令牌是否足够，当令牌数减为零时则拒绝新的请求；
漏桶则是按照常量固定速率流出请求，流入请求速率任意，当流入的请求数累积到漏桶容量时，则新流入的请求被拒绝（无法支持大突发）；
令牌桶限制的是平均流入速率（允许突发请求，只要有令牌就可以处理，支持一次拿3个令牌，4个令牌），并允许一定程度突发流量；
漏桶限制的是常量流出速率（即流出速率是一个固定常量值，比如都是1的速率流出，而不能一次是1，下次又是2），从而平滑突发流入速率；
令牌桶允许一定程度的突发，而漏桶主要目的是平滑流入速率；
两个算法实现可以一样，但是方向是相反的，对于相同的参数得到的限流效果是一样的。

32.GC CMS，CMS的参数
33.JVM的一些排查工具jstat, jstack ,jmap
34.工作中遇到的问题如何排查
35.一排盒子，每个盒子上标了能走的最大步数，从第一个盒子开始，判断能否走到最后的盒子
36..栈，增加一个max方法；
37..自己设计hash；
38.微博限定用户每次输入最多140个字符，用户如果传字符串很长的链接，怎么办
39. 输入一串空格分开的整数，相邻不会重复如：1 2 4 3 5，只返回其中一个峰值就可以，比如返回 4 或者 5
峰值定义：大于相邻两个数字就是峰值；对于头尾两个数字，分别大于相邻的一个数字即算峰值
40.二叉树镜像
41.两个线程，一个只能存有数组1、2、3和另一个存有a、b、c，然后通过调度，最终结果输出1a2b3c
42..输入一个int数组，返回一个数组，其中奇数都在左边，偶数都在右边
附加条件 不使用额外的空间
43.java多线程知识点，如synchronized，reentrantLock以及两者比较
44.java线程池，submit跟execute的区别
45.stack实现一个min方法，O(1)的复杂度
46.数据库两种引擎比较
47.数据库3个字段的联合索引，在用单字段时能否命中索引
48.数据库如何建索引，和如何分库分表
49.找到一个文件里出现次数最多的的数字，文件大小远大于内存容量
50.10G文件1G内存，
51.打印重复数字
52.查找前topK
53. 给一个数组和一个整数，输出数组中所有和为给定整数的元素下标
54. MySQL两种存储引擎的差异；
55. where a>1 and b>1;where a = 1; where b = 2,如何为这种条件语句建立索引；
56. LRU的实现
57. 介绍一个项目中遇到的问题。 
58. 一个100G的文件，内存只有8G，如何给文件排序，文件内容都是按行存储的URL
59. a.产品设计过程中面对的挑战和难点；b、周围同事对我的评价；c、产品设计考虑的几个点
60. .k路归并排序           
61.lru原理要非常详细的数据结果和过程结构       
62.给个数组，只有重复的，求所有和为21的下标:不用n2的暴力算法，要考虑数字相同的下标，先说思路没问   题才能共享屏幕写
63. 根据二叉树前序遍历生成avl树
64. 编程题：string转double
65、hashmap实现方式
66、数据库事务、隔离级别
mysql=innodb
快照读（读的是某个版本的缓存数据）
当前读（读的最新已被提交的数据）
快照读加for update,或in share mode 升级为当前读
rc解决脏读
rr解决不可重复读，脏读
s解决幻读，不可重复读，脏读
innodb+rr其实解决了不可重复读，手动控制也可以解决幻读
不可重复读：一个事务两次当前读，读到的某条数据发生了变化或条数发生变化（innodb保证加nextKey锁解决）；
幻读：是一个事务一次快照读+一次insert操作（比如先判断数据是否存在，不存在时则插入，但可能别别的事务已插入，但当前事务却始终无法读到该数据，因为当前事务我们一般采用的是快照读），innodb允许程序员将快照读升级为当前读（加nextkey锁），防止别人插入数据。但是这种情况，所以快照读升级为当前读，和s隔离级别无差异了。所以一般也说innodb并没有自动完全解决幻读，因为还是需要手动控制代码调整来防止。
死锁例子：
https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlock-example.html
预发死锁：
https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlocks-handling.html
f you use locking reads (SELECT ... FOR UPDATE or SELECT ... FOR SHARE), try using a lower isolation level such as READ COMMITTED.

buffer pool（LRU）
数据库自带的缓存，如果有sql可能加载大量只会被读一次的数据到缓存，岂不是起不到作用？需要配置innodb_old_blocks_pct=37%(默认是old page占链表的37%，如果1秒之内oldpage被访问， 并不会被放到new-page,超过1s[innodb_old_blocks_time]时，会被放到new-page)
数据库LRU加载机制：
数据页第一次被加载进BufferPool时在old区头部。
当这个数据页在old区，再次被访问到，会做如下判断
如果这个数据页在LRU链表中old区存在的时间超过了1秒，就把它移动到young区
这个存在时间由innodb_old_blocks_time控制
这个机制要清晰。
怎么理解mysql的可重复读？答：在多次当前读情况下，gap范围内条数总不变。这就需要组合各种场景，比如第一个事务要insert,delete，倘若不加锁，会不会导致别的事务里的当前读存在读到数量不一致的情况？可以采用假设法来反证得到我们要的结果。死记硬背这么多的锁级别很容易出错。

67、Out Of memory Error 跟 Stack Overflow Error的比较
一个是堆内存溢出（过大对象直接进入老年代-fgc-不够用；对象从新生带升级到老年代-fgc-不够用；）
当metaspace不沟通时，也会oom
一个是栈溢出（一般发生在递归）

68、数据库的隔离级别
ru,rc,rr,s

69、java 的 array 跟 list的比较，底层原理
数组和链表

70、有sql的编程题，是问每门课程都大于80分的学生名字
71、java编程题，a、反转一句英语的所有单词：hello world - > world hello

72、tcp，三次握手；ssl。
ssl四次握手：
客户端发random1+支持的算法
服务端返回选择的算法+服务端random2+服务端公钥
客户端产生random3，加密返回。根据random1,2,3产生sessionkey(对称密钥)
服务端根据random1,2,3产生sessionkey(对称密钥)

73、对称性加密跟非对称性加密的比较，使用场景
性能差100倍。对称加密用于数据传输，非对称用于握手加密
https使用了对称加密+非对称加密
数据存储可以采用对称加密

74、数据库事务
75、java的多线程
76、涉及面好广 还有密码学的，加密算法RSA
77、搜索引擎倒排原理及实现方式
78、Redis高可用方案
79、主键与索引的联系和区别
https://blog.csdn.net/u010727189/article/details/79399384

80、索引的实现方式，为什么会采用这种数据结构
B+树。从AVL->红黑树->多叉树（尽可能降低高度，从而减少磁盘操作次数）

81、Redis缓存删除策略
82、编码实现LRU算法
83、统计大量访问日志（分几百M 和 几百G的场景）；得出访问次数最多的前K个人 （单台机器实现）
84. 给你一个连续素数数组 让你找出增长比第k小的位置
85. 代码题：有序数组 A = [1, 2, 2, 3, 3, 5, 5, 5]，b = 5，在A中找出b的序号的上下界，考察思路和代码熟练度

86.自我介绍、项目经历（会结合你的项目经历即兴问一些相关联的问题，以设计思路，框架性的思考为主）
   HTTPS原理
   Oracle MySQL特性、优劣势
   Redis等前沿技术栈的知识面
87. python的装饰器
     mysql的innodb与myisam区别，索引
   .  10G文件，1G内存，找出最大的K个数，找出重复数
88. 简单的一道系统设计题：用redis做限流
    然后是Mysql各种基础知识
    然后是HTTP状态码 502/504
    然后是一道系统设计题：微信扫码登录
89. 成都后台笔试:
 是输入[I love byte bytedance] Ilovebytebytedance
 然后判断中括号里的单词能否组成括号外的语句
 中括号里的单词用空格符隔开，括号外的语句不能由单词重叠组成
如果输入这个
 [I love byte bytedance] Ilovebytedance，预期结果返回true
90. 南京大数据后台一面：redis相关的 zset结构 redis内存回收 多线程拒绝策略 数据库B树索引 treemap原理
然后算法题一个是 给定一个数字只移动以为要求结果比原值大并且是所有方案中最小的值
还有个算法题是16进制加法
91. 成都后台一面:. mybatis的Mapper接口映射到sql文件的实现原理
                                 mysql联合索引,实现,优点
                                 一个算法题，两数组a,b，把a数组中在b数组出现的数字，按照它在B数组中出                现的顺序进行位置调整。
                               微博等热门评论，在分页到很深的时候，如何进行优化
92. 成都后台一面
mysql相关： 
引擎innodb特性，锁，事务

mq：
kafka，rocketmq，同步机制和事务机制
编程实现的是泛型链表的添加和删除，主要是看敲代码的过程和怎样解释自己的代码吧

93.杭州后台；删除链表中重复的结点
在一个排序的链表中，存在重复的结
点，请删除该链表中重复的结点，重复
的结点不保留，返回链表头指针。例
如，链表1－＞2－＞3－＞3－＞4－4－＞5处理后为
1->2->5
总结:比较注重CS修养、底层源码实现 

94.上海后台：
1.输入一个二叉树，以及指定一个层次，从右向左输出这一层的所有节点
2.设计一个LRU，尽可能的支持高并发
3.session 怎么用 cookie 实现的，session 和 cookie 的区别。
4.java 线程池是怎么工作的。
5.java bio nio 的区别
6.nio是怎么实现的
7.CMS的流程
8.CMS 的参数
9.线上的 GC 是怎么配置的？
10.redis 主从怎么实现的。

95 北京后台一面:介绍一下项目，链表逆序，设计一个王者的组队系统
    北京: 限流 zset redis pipieline http请求过程详解 mysql 索引 堆排序 求前k大个数

96 上海:
  1,sql什么时候不适合用索引，索引太多会有啥问题，同步io和异步io区别，coding是多个数组合并，follow      up 如果数组个数非常多但是每个里面的内容比较少
      2,http和https的区别，https的实现

96 成都后台开发：第一个题是'反转二叉树'，第二个题是N皇后问题(8皇后问题的扩展)


97. 1.单链表，每k个进行一次翻转
2.设计一个限流工具，每5s允许一个请求，多的请求丢弃
3.设计一个限流工具，在第1，6，11，16秒允许一个请求，多的丢弃
4.设计一个限流工具，在第1，6，11，16秒允许一个请求，多的排队等待

其他问题：
1.介绍一个最熟悉的项目，里面有什么亮点
2.简单工厂，抽象工厂，方法工厂的区别
3.java线程池的有哪些参数，以及意义

98.成都后台一面
1.concurrentMap实现高并发的原理
2.java nio 和 bio 的区别
3.redis 的常用数据结构、持久化方式、写入时rdb机制
4.https机制，http服务端推送
5.写一个 lru cache，get set delete 都在o(1)
参考java。linkedhashmap。linkedentry extend hashmap.entry,linkedentry维护before,next指针。
整个lhashmap维护head,tail指针。
get,set，del操作都和hashmap一致，并在最后加上一个重新排序的操作（只需要将e=get()的结果，取出before,after，head,tail四个节点，将e放在tail的最后即可）
遍历时：根据head,tail来顺序访问
淘汰时：tail因为是最新的数据，从head开始淘汰

99.深圳后端
python的gil锁
消息队列如何实现高吞吐量
http状态码
数据库外键的优缺点
算法给定ab两个数，a可以+2019，×5，×17，问最少经过多少步可以将a变换到b（2019.5.17是今天的日期，完全是现场临时随便编了个题）

100.
1. 介绍下项⽬目
2. 项⽬目中的难点是什么，怎么解决的
3. 算法：数组中第K⼤大的数，分析时间复杂度
4. volatile的作⽤
5. 怎么保证原⼦性
6. 线程安全的单例模式
7. ThreadLocal的作⽤，应⽤场景是什么
8. HashMap和TreeMap的区别，以及各自的优势
9. Mysql的索引是怎么实现的，为什么这么实现，优势在哪

101. 北京后台1面：
   1、502 504
   2、cookie，session
   3、mysql优化
   4、mysql MyISAM与innodb的区别
   5、redis分布式锁
   6、缓存一致性
   7、mysql索引存储
   8、jvm垃圾回收算法
102. 深圳后台一面：
    1 go string的数据结构
    2 goroutine 的调度
    3 数组中第k大的数
103. 武汉后台一面：1.ORACLE 和mysql的区别
2.工作中Spring Aop的案例
3.activemq和rabbitmq的区别
4.数据库中的索引和事务

104上海后台一面：
Go比Python的优缺点。
Go的任务调度。
Go的channel为什么可以被goroutine安全操作而不需要上锁。
网络知识：TCP的三次握手、四次挥手。
分布式锁。
数据库的分布式事务。
算法题：遍历树，求从根节点到叶子节点和为某值的路径。

105北京后台一面
一排相邻的糖果屋，不能从相邻糖果屋买糖，请问最大能买多少颗糖？
输入[1,2,3,1] 输出4




106上海后台一面：
rabbitmq的代替方式
聚集索引和飞聚集索引区别
哪些情况会用到索引
怎么排查慢查询
事务隔离级别
Tcp三次握手四次挥手
Udp
select poll epoll
算法：按层输出树的结点
Http各状态码
Session和cookie
cookie是客户端用，session用于服务端。服务端一般根据cookie找session来识别用户
当然也有别的方式：客户端存储加密后的session（显然不如存在服务端）

107. 杭州后台一面二面：
1、ctrl c过程；
2、去除重复列表；
3、单链表求和；

二面：
1：多个人玩贪吃蛇设计 
2：项目开发性设计，自己设计，自己定规则
3.B B+ 跳表区别 时间复杂度
4.Https与http区别， tls的加密流程
5.自增ID与uuid的优劣
自增id优点是适合排序，占用空间小（long=64bit）
新老数据迁移时非常困难，很难保证唯一。有外键更困难
uuid=128bit，不适合排序，可保证全局唯一性。适合迁移

6.Redis的事务以及实现方式
7.给定字符串的全排列
8. 介绍经历、java线程池基础知识、自己实现一个线程池，然后是二叉树的bfs，最小公共子串得长度，最大不重复子串的长度
9.dubbo的容错机制有哪些、负载均衡机制有哪些
10.fail-fast
11. 45.一个有序数组，求一个数出现的次数
12. 数据库索引：表有3列a,b,c，需支持查询（a,b）(b) (b,c)，索引如何建
13.反转二叉树
14.数据库表（id, name, parentId）如何组装成树?
15. 主键索引和非主键索引的区别
16. 数据库事务的隔离级别
17. redis和memcached
18. 数据库查询优化
19. 编程题，贪心算法
20.不同字符最大子串
根据给定的输入字符串，返回包含有最多
k个不同字符的子字符串的长度及子字符
串在输入字符串的起始下标如果有多个
符合条件的子字符串，则返回第一个子字
符串的下标
输入描述
输入为一个待校验的字符串
输出描述
两个数字，分表表示子字符串的长度以及子字符串首字符在输入字符串的下标

武汉后台:
1. 介绍下项⽬目，⽐比较详细(包括线程数，负载，机器器压⼒力力等)
2. 设计微博评论的存储系统，要求⽀支持分⻚页
3. Redis的hash和string的区别以及各⾃自的优势和使⽤用场景
4. 算法：给出⼀一个xml格式的字符串串，校验这个xml是否是合法

成都后台：
手上有一堆扑克牌，牌面顺序是1234(从上到下)，
规则是，
1.取手中最上面的牌放入桌上牌堆的最上面
2.如果手中还有牌，则将手中最上面的牌放入手中牌堆的最下面
3.重复1、2步骤
这时桌上的牌堆顺序是4231(从上到下)


题目：已知桌上牌堆的顺序，求原来手中牌堆的顺序

有一个数组 -1 3 2 4 5 -6 7 -9,将该数组的负数和正数分离开
多余的数放入数组的尾部
比如3 -1 2 -6 4 -9 5 7

上海后台：数字金额转为中文说法，例如1001.25转为壹仟零壹元两毛五分

北京后台一二面：1.Redis的分布式锁，单节点和集群的优缺 2.自己项目里的mysql规模3.10g文件，1g内存，             求top k和  重复数字4.两个单向链表按照十进制求和，不能使用已经有的数据结构和注意链表方向，比如1-＞3-＞5-＞9，5-＞4，等于1-＞4-＞1-＞3

深圳后台:
   1、一千个棋子，甲先取乙后取，每次最多取七个最少取一个，问是否有一个方案让甲一定赢
   2、3×7的格子，从左上角到右下角，只能往右或者往下，有多少种走法
   3、一个不均匀硬币，如何抛出均匀概率
   4、然后有一个生成0到13随机数的算法，如何用它均匀生成0到9随机数
   5、两千万高考生成绩如何排序
   6、用链表表示的大数求和
上海后台
MySQL中的事务隔离级别
协程的原理和实现
gevent中的协程的实现
反转链表
距离矩阵，从左上开始，只能往右或往下，求从左上到右下的最短距离。



三面 ：
1.leetcode 670，然后系统设计题，设计群消息已读功能，
三面应该是1道算法1道系统设计

2、假设是一个抽奖的游戏，不同的人是有不同的概率倍数，是一个整数，例如1、3、5...
输入100万人，要求抽奖抽出来2万个人；并且假设每个人都有一个唯一id

3.写一个函数做下抽奖，输入和输出的数据结构自己设计
4、然后就是项目上的一些东西  redis 高可用怎么实现、 redis过期怎么实现、Mysql索引的注意事项
5 code review
6.数据库索引+前缀匹配
7.缓存设计
8.并发控制（乐观锁，悲观锁）
9.xss && csfr
10. 杭州后台三面：推送的频率控制，   抖音评论列表的设计及缓存实现，   MySQL索引怎么建、http头、http header
11. sizeof运算符计算要考虑哪些因素
     函数定义int a[100000]可能出现什么问题
     一百万个用户抽奖，奖品只有1000个，每人最多中奖一次，每个用户中奖倍率不一样，给出代码实现。
12. 1.     问了redis数据结构和实现
      2.     问hashmap
      3.     浅拷贝深拷贝实现
      4.     把一面的算法题再做一次
13. 项目聊很多（使用的中间件实现原理）
     带权重抽奖代码实现
     类加载过程
     热加载、热替换
     jvm参数：-server -client
    JIT即时编译原理
    排查线上问题经历、思路
    聊部门情况
